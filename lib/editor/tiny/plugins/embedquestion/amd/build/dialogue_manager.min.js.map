{"version":3,"file":"dialogue_manager.min.js","sources":["../src/dialogue_manager.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport Templates from 'core/templates';\nimport {get_string as getString} from 'core/str';\nimport Modal from 'core/modal';\nimport ModalFactory from 'core/modal_factory';\nimport Pending from 'core/pending';\nimport {addIconToContainerRemoveOnCompletion} from 'core/loadingicon';\nimport {getRelevantContextId} from './options';\nimport {call as fetchMany} from 'core/ajax';\nimport Notification from 'core/notification';\nimport Fragment from 'core/fragment';\n\n/**\n * Manages the embed question dialog.\n *\n * @module    tiny_embedquestion/dialogue_manager\n * @copyright 2024 The Open University\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nexport const DialogManager = class {\n\n    /** @property {Object} current Tiny MCE editor instance */\n    editor = null;\n\n    /** @property {Object} current display dialog */\n    currentModal = null;\n\n    /**\n     * Dialog constructor.\n     *\n     * @constructor\n     * @param {Object} editor current editor instance.\n     */\n    constructor(editor) {\n        this.editor = editor;\n    }\n\n    /**\n     * Displays a modal dialogue for managing embed question.\n     *\n     * @async\n     */\n    displayDialogue = async() => {\n        if (typeof Modal.create !== \"undefined\") {\n            this.currentModal = await Modal.create({\n                large: true,\n                title: getString('pluginname', 'tiny_embedquestion'),\n                body: '<div class=\"tiny_embedquestion-wrap\"></div>',\n                show: true,\n                removeOnClose: true\n            });\n        } else {\n            // TODO Need to be remove after we no longer support 4.2 and below.\n            this.currentModal = await ModalFactory.create({\n                title: getString('pluginname', 'tiny_embedquestion'),\n                body: '<div class=\"tiny_embedquestion-wrap\"></div>',\n                large: true,\n                removeOnClose: true\n            });\n            this.currentModal.show();\n        }\n\n        const pendingModalReady = new Pending('tiny_embedquestion/displayDialogue');\n        const body = this.currentModal.getBody()[0];\n        addIconToContainerRemoveOnCompletion(\n            body, pendingModalReady\n        );\n\n        let existingCode = this.getEmbedCodeFromTextSelection(this.editor);\n        if (existingCode) {\n            existingCode = existingCode.embedCode;\n        }\n        const dialogManager = this;\n        Fragment.loadFragment('tiny_embedquestion', 'questionselector', getRelevantContextId(this.editor),\n            {contextId: getRelevantContextId(this.editor), embedCode: existingCode}).then(function(html, js) {\n\n            Templates.replaceNodeContents(body, html, js);\n            body.querySelector('#embedqform #id_submitbutton').addEventListener('click', dialogManager.getEmbedCode);\n            pendingModalReady.resolve();\n            return dialogManager.currentModal;\n        }).catch(Notification.exception);\n    };\n\n    /**\n     * Handler for when the form button is clicked.\n     * Make an AJAX request to the server to get the embed code.\n     *\n     * @param {Event} e - the click event.\n     */\n    getEmbedCode = (e) => {\n        e.preventDefault();\n        const iframeDescription = document.getElementById('id_iframedescription').value;\n        const questionIdnumber = document.getElementById('id_questionidnumber').value;\n        const dialogManager = this;\n        // Required value of questionidnumber.\n        // Note that the form also validates this, and deals with displaying a message to the user.\n        if (!questionIdnumber) {\n            return;\n        }\n\n        // Validate iframedescription.\n        // If it is present, then it must have at least 3 characters and a maximum of 100 characters.\n        // (It can be left blank to get the default description.)\n        // Note that the form also validates this, and deals with displaying a message to the user.\n        if (iframeDescription.length && (iframeDescription.length < 3 || iframeDescription.length > 100)) {\n            return;\n        }\n\n        dialogManager.getEmbedCodeCall(iframeDescription, questionIdnumber).then(function(embedCode) {\n            dialogManager.insertEmbedCode(embedCode);\n            return dialogManager;\n        }).catch(Notification.exception);\n    };\n\n    /**\n     * Ajax call to get the embed code from back end.\n     *\n     * @param {String} iframeDescription - Description for the the embed code\n     * @param {Number} questionIdnumber - question id number.\n     * @returns {Promise}\n     */\n    getEmbedCodeCall = (iframeDescription, questionIdnumber) => {\n        return fetchMany([{\n            methodname: 'filter_embedquestion_get_embed_code',\n            args: {\n                courseid: document.querySelector('input[name=courseid]').value,\n                categoryidnumber: document.getElementById('id_categoryidnumber').value,\n                questionidnumber: questionIdnumber,\n                iframedescription: iframeDescription,\n                behaviour: document.getElementById('id_behaviour')?.value || '',\n                maxmark: document.getElementById('id_maxmark')?.value || '',\n                variant: document.getElementById('id_variant')?.value || '',\n                correctness: document.getElementById('id_correctness')?.value || '',\n                marks: document.getElementById('id_marks')?.value || '',\n                markdp: document.getElementById('id_markdp')?.value || '',\n                feedback: document.getElementById('id_feedback')?.value || '',\n                generalfeedback: document.getElementById('id_generalfeedback')?.value || '',\n                rightanswer: document.getElementById('id_rightanswer')?.value || '',\n                history: document.getElementById('id_history')?.value || '',\n                forcedlanguage: document.getElementById('id_forcedlanguage')?.value || ''\n            }\n        }])[0];\n    };\n\n    /**\n     * Handles when we get the embed code from the AJAX request.\n     *\n     * @param {String} embedCode - the embed code to insert.\n     */\n    insertEmbedCode = (embedCode) => {\n        const existingCode = this.getEmbedCodeFromTextSelection(this.editor);\n        if (existingCode) {\n            // Replace the existing code.\n            const parent = this.editor.selection.getNode();\n            const text = parent.textContent;\n            parent.textContent = text.slice(0, existingCode.start) +\n                embedCode + text.slice(existingCode.end);\n        } else {\n            this.editor.insertContent(embedCode);\n        }\n        this.currentModal.destroy();\n    };\n\n    /**\n     * Get the embed  code of the current selected text,\n     *\n     * @param {TinyMCE} editor\n     * @returns {boolean|Object}\n     * return false if we can't find the match pattern.\n     * return Object {start: start position of the text, end: end position of the text, embedCode: embed code of the string}\n     */\n    getEmbedCodeFromTextSelection = (editor) => {\n\n        // Find the embed code in the surrounding text.\n        const selection = editor.selection.getSel(),\n            selectedNode = editor.selection.getNode(),\n            pattern = /\\{Q\\{(?:(?!\\}Q\\}).)*\\}Q\\}/g;\n        let text,\n            returnValue = false,\n            patternMatches;\n\n        if (!selection) {\n            return false;\n        }\n        const range = selection.rangeCount ? selection.getRangeAt(0) : null;\n        if (!range) {\n            return false;\n        }\n        text = selectedNode.textContent;\n        patternMatches = text.match(pattern);\n\n        if (!patternMatches || !patternMatches.length) {\n            return false;\n        }\n        // This pattern matches at least once. See if this pattern matches our current position.\n        // Note: We return here to break the Y.Array.find loop - any truthy return will stop any subsequent\n        // searches which is the required behaviour of this function.\n        for (let i = 0; i < patternMatches.length; ++i) {\n            let startIndex = 0;\n            while (text.indexOf(patternMatches[i], startIndex) !== -1) {\n                // Determine whether the cursor is in the current occurrence of this string.\n                // Note: We do not support a selection exceeding the bounds of an equation.\n                const start = text.indexOf(patternMatches[i], startIndex),\n                    end = start + patternMatches[i].length,\n                    startMatches = (selection.anchorOffset >= start && selection.anchorOffset < end),\n                    endMatches = (selection.focusOffset <= end && selection.focusOffset > start),\n                    reserveStartMatches = (selection.anchorOffset <= end && selection.anchorOffset > start),\n                    reserveEndMatches = (selection.focusOffset >= start && selection.focusOffset < end);\n                if ((startMatches && endMatches) || (reserveStartMatches && reserveEndMatches)) {\n                    // Save all data for later.\n                    returnValue = {\n                        // Outer match data.\n                        start: start,\n                        end: end,\n                        embedCode: patternMatches[i]\n                    };\n\n                    // This breaks out the loop\n                    break;\n                }\n\n                // Update the startIndex to match the end of the current match so that we can continue hunting\n                // for further matches.\n                startIndex = end;\n            }\n        }\n        return returnValue;\n    };\n};\n"],"names":["constructor","editor","async","Modal","create","currentModal","large","title","body","show","removeOnClose","ModalFactory","pendingModalReady","Pending","this","getBody","existingCode","getEmbedCodeFromTextSelection","embedCode","dialogManager","loadFragment","contextId","then","html","js","replaceNodeContents","querySelector","addEventListener","getEmbedCode","resolve","catch","Notification","exception","e","preventDefault","iframeDescription","document","getElementById","value","questionIdnumber","length","getEmbedCodeCall","insertEmbedCode","methodname","args","courseid","categoryidnumber","questionidnumber","iframedescription","behaviour","maxmark","variant","correctness","marks","markdp","feedback","generalfeedback","rightanswer","history","forcedlanguage","parent","selection","getNode","text","textContent","slice","start","end","insertContent","destroy","getSel","selectedNode","patternMatches","returnValue","rangeCount","getRangeAt","match","i","startIndex","indexOf","startMatches","anchorOffset","endMatches","focusOffset","reserveStartMatches","reserveEndMatches"],"mappings":"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"}