define("tiny_embedquestion/dialogue_manager", [
    "exports",
    "core/templates",
    "core/str",
    "core/modal",
    "core/modal_factory",
    "core/pending",
    "core/loadingicon",
    "./options",
    "core/ajax",
    "core/notification",
    "core/fragment"
], function(
    _exports,
    _templates,
    _str,
    _modal,
    _modal_factory,
    _pending,
    _loadingicon,
    _options,
    _ajax,
    _notification,
    _fragment
) {
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }

    function _defineProperty(obj, key, value) {
        if (key in obj) {
            Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            obj[key] = value;
        }
        return obj;
    }

    /**
     * Manages the embed question dialog.
     *
     * @module    tiny_embedquestion/dialogue_manager
     * @copyright 2024 The Open University
     * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
     */
    Object.defineProperty(_exports, "__esModule", {
        value: true
    });

    _exports.DialogManager = void 0;

    _templates = _interopRequireDefault(_templates);
    _modal = _interopRequireDefault(_modal);
    _modal_factory = _interopRequireDefault(_modal_factory);
    _pending = _interopRequireDefault(_pending);
    _notification = _interopRequireDefault(_notification);
    _fragment = _interopRequireDefault(_fragment);

    _exports.DialogManager = class {
        constructor(_editor) {
            _defineProperty(this, "editor", null);
            _defineProperty(this, "currentModal", null);

            _defineProperty(this, "displayDialogue", async () => {
                if (_modal.default.create !== undefined) {
                    this.currentModal = await _modal.default.create({
                        large: true,
                        title: (0, _str.get_string)("pluginname", "tiny_embedquestion"),
                        body: '<div class="tiny_embedquestion-wrap"></div>',
                        show: true,
                        removeOnClose: true
                    });
                } else {
                    this.currentModal = await _modal_factory.default.create({
                        title: (0, _str.get_string)("pluginname", "tiny_embedquestion"),
                        body: '<div class="tiny_embedquestion-wrap"></div>',
                        large: true,
                        removeOnClose: true
                    });
                    this.currentModal.show();
                }

                const pendingModalReady = new _pending.default("tiny_embedquestion/displayDialogue");
                const body = this.currentModal.getBody()[0];

                (0, _loadingicon.addIconToContainerRemoveOnCompletion)(body, pendingModalReady);

                let existingCode = this.getEmbedCodeFromTextSelection(this.editor);
                if (existingCode) {
                    existingCode = existingCode.embedCode;
                }

                const dialogManager = this;

                _fragment.default.loadFragment(
                    "tiny_embedquestion",
                    "questionselector",
                    (0, _options.getRelevantContextId)(this.editor),
                    {
                        contextId: (0, _options.getRelevantContextId)(this.editor),
                        embedCode: existingCode
                    }
                ).then(function(html, js) {
                    _templates.default.replaceNodeContents(body, html, js);
                    body.querySelector("#embedqform #id_submitbutton").addEventListener("click", dialogManager.getEmbedCode);
                    pendingModalReady.resolve();
                    return dialogManager.currentModal;
                }).catch(_notification.default.exception);
            });

            _defineProperty(this, "getEmbedCode", (e) => {
                e.preventDefault();

                const iframeDescription = document.getElementById("id_iframedescription").value;
                const questionIdnumber = document.getElementById("id_questionidnumber").value;
                const dialogManager = this;

                if (questionIdnumber) {
                    if (
                        iframeDescription.length &&
                        (iframeDescription.length < 3 || iframeDescription.length > 100)
                    ) {
                        // Description length is invalid, do nothing
                    } else {
                        dialogManager.getEmbedCodeCall(
                            iframeDescription,
                            questionIdnumber
                        ).then(function(embedCode) {
                            dialogManager.insertEmbedCode(embedCode);
                            return dialogManager;
                        }).catch(_notification.default.exception);
                    }
                }
            });

            _defineProperty(this, "getEmbedCodeCall", (iframeDescription, questionIdnumber) => {
                return (0, _ajax.call)([
                    {
                        methodname: "filter_embedquestion_get_embed_code",
                        args: {
                            courseid: document.querySelector("input[name=courseid]").value,
                            categoryidnumber: document.getElementById("id_categoryidnumber").value,
                            questionidnumber: questionIdnumber,
                            iframedescription: iframeDescription,
                            behaviour: (document.getElementById("id_behaviour")?.value) || "",
                            maxmark: (document.getElementById("id_maxmark")?.value) || "",
                            variant: (document.getElementById("id_variant")?.value) || "",
                            correctness: (document.getElementById("id_correctness")?.value) || "",
                            marks: (document.getElementById("id_marks")?.value) || "",
                            markdp: (document.getElementById("id_markdp")?.value) || "",
                            feedback: (document.getElementById("id_feedback")?.value) || "",
                            generalfeedback: (document.getElementById("id_generalfeedback")?.value) || "",
                            rightanswer: (document.getElementById("id_rightanswer")?.value) || "",
                            history: (document.getElementById("id_history")?.value) || "",
                            forcedlanguage: (document.getElementById("id_forcedlanguage")?.value) || ""
                        }
                    }
                ])[0];
            });

            _defineProperty(this, "insertEmbedCode", (embedCode) => {
                const existingCode = this.getEmbedCodeFromTextSelection(this.editor);

                if (existingCode) {
                    const parent = this.editor.selection.getNode();
                    const text = parent.textContent;
                    parent.textContent = text.slice(0, existingCode.start) + embedCode + text.slice(existingCode.end);
                } else {
                    this.editor.insertContent(embedCode);
                }

                this.currentModal.destroy();
            });

            _defineProperty(this, "getEmbedCodeFromTextSelection", (editor) => {
                const selection = editor.selection.getSel();
                const selectedNode = editor.selection.getNode();
                let text, patternMatches;
                let returnValue = false;

                if (!selection) {
                    return false;
                }

                if (!(selection.rangeCount ? selection.getRangeAt(0) : null)) {
                    return false;
                }

                text = selectedNode.textContent;
                patternMatches = text.match(/\{Q\{(?:(?!\}Q\}).)*\}Q\}/g);

                if (!patternMatches || !patternMatches.length) {
                    return false;
                }

                for (let i = 0; i < patternMatches.length; ++i) {
                    let startIndex = 0;

                    while (text.indexOf(patternMatches[i], startIndex) !== -1) {
                        const start = text.indexOf(patternMatches[i], startIndex);
                        const end = start + patternMatches[i].length;

                        const startMatches = selection.anchorOffset >= start && selection.anchorOffset < end;
                        const endMatches = selection.focusOffset <= end && selection.focusOffset > start;
                        const reserveStartMatches = selection.anchorOffset <= end && selection.anchorOffset > start;
                        const reserveEndMatches = selection.focusOffset >= start && selection.focusOffset < end;

                        if ((startMatches && endMatches) || (reserveStartMatches && reserveEndMatches)) {
                            returnValue = {
                                start: start,
                                end: end,
                                embedCode: patternMatches[i]
                            };
                            break;
                        }

                        startIndex = end;
                    }
                }

                return returnValue;
            });

            this.editor = _editor;
        }
    };
});

//# sourceMappingURL=dialogue_manager.min.js.map